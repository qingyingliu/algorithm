---
layout: post
title: Tree
date: 2018-10-28 19:26:24
categories: data-structure
description: 数据结构之树的知识
---
### 树的相关术语
1. 树的定义： 树（Tree)是含有n**(n>0)**个结点的有限集合T，其中：
	- 有且仅有一个特定的结点，称为树的根(root)
	- 当n>1时，其余结点可分为m(m>0)个**互不相交的**有限集合T1,T2,T3...,其中每一个集合又是一棵树，称为根的子树。
	所以，根据定义，树有一下特点：
	- 树至少有一个结点——根
	- 树的子树互不相交
2. 结点： 表示树中的元素，包括**数据项**及若干指向其**子树的分支**。
3. 结点的度： 结点拥有的子树的个数。
4. 叶子： 结点的度为0的结点。
5. 分支结点：结点的度不为零的结点，非终端结点
6. 孩子： 结点的子树的根
7. 双亲： 结点的上层结点
8. 兄弟： 同一个双亲的孩子
9. 树的度： 一颗树中所有结点的最大度
10. 结点的层次： 从根节点算起，根为第一层，它的孩子为第二层...（注：也可以规定根节点为第0层，然后每下一层层数加一）
11. 深度： 树中的结点的最大层次
12. 森林： m颗树互不相交的树的集合
13. 有序树： 各个子树的次序是有意义的，不能交换
14. 无序树： 各个子树的次序不影响树，可以交换次序
例子：
![](/uploads/Tree_1.png)

### 树的5种表示方法
1. 图形表示法： 画出树的图形结构。比如：
![](/uploads/Tree_2.png)
2. 嵌套集合表示法： 根据圈的大小来表示层次关系。比如:
![](/uploads/Tree_3.png)
3. 广义表示法： 用括号来表示层次关系
![](/uploads/Tree_4.png)
4. 凹入表示法（目录表示法）： 根据缩进的不同来表示层次关系，类比目录。
![](/uploads/Tree_5.png)
5. 左孩子右兄弟表示法：这是一种将树转换成二叉树的方法。
将每一个结点的坐孩子和右兄弟分别表示二叉树的左孩子和右孩子。
![](/uploads/Tree_6.png)

### 二叉树
1. 二叉树的定义： 二叉树是n(n>=0)个结点的有限集，它或为**空树**或由一个根节点和两颗分别称作左子树和右子树的互不相交的二叉树构成。
注意： 二叉树的子树有左右之分，所以二叉树是有序树。
2. 满二叉树： 深度为k且含有2^k-1个结点的二叉树。
   特点： 每一层上的结点树都是最大结点数。
   ![](/uploads/Tree_7.png)
3. 完全二叉树： 若设二叉树的深度为h，除第h 层外，其它各层(1～h-1) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树。
	特点： 叶子结点只可能出现在层次最大的两层出现。
	![](/uploads/Tree_8.png)
4. 二叉树的性质：
	- 性质1： 二叉树的第i层上之多有2^(i-1)个结点
	证明： 
	i=1时，只有一个根结点；
	i=k时，假设对于所有的k命题成立，则
	当i=k+1，当前k层的每一个结点都有两个子树时，第i层的结点个数最大， 此时最大结点个数为2*2^(k-1)=2^k。得证命题成立。
	- 性质2： 深度为k的二叉树最有有2^k-1个结点。
	证明： 结点最大个数sum=2^0+2^1+2^2+...+2^(k-1)=2^k-1
	- 性质3： 若在任意一颗二叉树中，有n0个叶子结点，有n2个度数为2的结点，则n0=n2+1。
	证明： 假设n1为二叉树中度为1的结点数。
	因为 二叉树中的度均小于2，
	所有 树的总结点树n=n0+n1+n2
	在二叉树中，除根节点外，其余结点只有一个分支进入。
	设B为分支总数，则n=B+1.
	又分支由度为1和度为2的结点射出，所以： B=n1+2*n2
	联立上式，解得n0=n2+1
	证毕！
	- 性质4： 具有n个结点的完全二叉树的深度为floor(log2(n))+1.
	证明： 假设二叉树的深度为h，则2^(h-1)-1<n<=2^h-1，
	所以 h-1<log2(n+1)<=h。
	所以h=log2(n+1)(向上取整)=log2(n+1)=[log2(n)](向下取整)+1
	证毕！
	- 性质5： 对于**完全二叉树**的任意结点i，有
	    (1)如果i==1，则是二叉树的根
		(2)如果2i>n，则结点i没有左孩子;如果2i<=n，则其左孩子是2n
		(3)如果2i+1>n，则结点i没有右孩子,否则右孩子是2n+1
5. 二叉树和树的转换
二叉树和树的转换方法是前面提到的树的左孩子右兄弟表示方法。然后再旋转45度即可。对应关系如下：
![](/uploads/Tree_9.png)
可以总结为下面三个步骤：
	1. 加线： 给兄弟关系的结点加线。
	2. 抹线： 抹去每个结点的右孩子的线
	3. 旋转： 将同一孩子的连线绕左孩子顺时针旋转45度
	
例子：
![](/uploads/Tree_10.png)

6. 二叉树还原成树
还原的操作是把所有的右孩子变成兄弟（逆操作）

7. 森林转换成二叉树：
方法是： 先森林变兄弟，然后再转为二叉树。
例子：
![](/uploads/Tree_11.png)

8. 二叉树还原成森林
方法： 把最右边的子树变成森林，其余右子树变成兄弟。
例子：
![](/uploads/Tree_12.png)

### 二叉树的创建和遍历
1. 二叉树的创建：
	a. 完全二叉树类型的创建： 这种类型用顺序存储比较好。当根结点下标为1时，假设有结点下标为i，则左子树的根的下标可以表示为2i，右子树的根的下标为2i+1。
	假设输入按照先序遍历的结果输入，则创建的方法为：
	```c++
	//函数不用返回根结点是因为我们选定了根结点为1
	void constructBiTree(int curRoot){
		int data;
		cin>>data;
		if(data=="0")	//用0表示空
		{
			//在这里可以设置一些标记来标记空
		}
		else{
			constructBiTree(curRoot*2);
			constructBiTree(curRoot*2+1);
		}
	}
	```
	b. 一般的二叉树也可以用链表来构建
	```c++
	Node* constructBiTree(Node* curRoot){
		int data;
		cin>>data;
		if(data=="0")	//用0表示空
		{
			return null;
		}
		else{
			curRoot->left=new Node();
			curRoor->right=new Node();
			curRoot->left=constructBiTree(curRoot->left);
			curRoot->right=constructBiTree(curRoot->right);
			return curRoot;
		}
	}
	```
2. 二叉树的遍历
	a. 先序遍历： 先访问根结点，然后访问左子树，然后访问右子树
	b. 中序遍历： 先遍历左子树，然后遍历根结点，最后遍历右子树
	c. 后序遍历： 先遍历左子树，然后遍历右子树，最后访问根结点
	
代码的实现的话，根据不同的遍历，只需要改变访问左子树、根和右子树的顺序即可。这里给出先序遍历的代码：

	```c++
	 void preOrder(Node* cur){
		if(cur){
			visite(cur);    //表示访问该结点
			preOrder(cur->left);
			preOrder(cur->right);
		}
	}
	```
	
还有一种层次遍历，如果是用数组表示树的话，直接安装下标的顺序输出即可。如果是链式存储的话，可以使用队列来进行广度优先遍历：

```c++
void levelOrder(Node* root){
		queue<Node*> q;
		q.push(root);
		while(!q.empty()){
			Node* top=q.front();
			q.pop();
			visite(top);
			if(top->left){
				q.push(top->left);
			}
			if(top->right){
				q.push(top->right);
			}
		}
	}
```

### 树的遍历
- 先根遍历： 先访问树的根结点，然后依次遍历根的每颗子树。
- 后根遍历： 先依次遍历每颗子树，然后访问根结点。
- 层次遍历： 逐层依次访问每个结点
例子： 
![](/uploads/Tree_13.png)

### 森林的遍历
- 先序遍历： 若森林不空，则：
	a. 访问第一棵树的根结点
	b. 先序遍历第一颗树的根结点的子树森林
	c. 现需遍历除了第一棵树之外其余树构成的森林
	即先序遍历对于的二叉树
- 中序遍历： 若森林不空，则：
	a. 中序遍历第一颗树的根结点的子树森林
	b. 访问第一棵树的根结点
	c. 中序遍历除第一颗树之外的其余树构成的森林
	即中序遍历对于的二叉树
	例子：
	![](/uploads/Tree_14.png)
### 线索二叉树
定义： 二叉树添加了**直接指向节点的前驱和后继的指针**的二叉树称为线索二叉树。
![](/uploads/Tree_18.png)
也就是说：
- 把所有的空指针域中的lchild，改为它的前驱结点(图6-11-3)
- 把所有的空指针域的rchild，改为它的后继节点(图6-11-2)
![](/uploads/Tree_16.png)
![](/uploads/Tree_15.png)

通过图6-10-4（空心箭头实线为前驱，虚线黑箭头为后继），更容易看出，其实线索二叉树，等于是把一棵二叉树转变成了一个双向链表，这样对我们的插入删除结点，查找某个结点都带来了方便。所以我们把对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化。
![](/uploads/Tree_17.png)

### Huffman编码
在之前已经写过这篇博客了：[Huffman code](https://lewin671.github.io/2018/10/23/huffman-tree/)
